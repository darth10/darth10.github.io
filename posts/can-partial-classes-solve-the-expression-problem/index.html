<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>darth10.github.io: Can partial classes solve the expression problem?</title>
    <link rel="canonical" href="https://darth10.github.io/posts/can-partial-classes-solve-the-expression-problem/">
    <link rel="icon" href="/img/logo.png">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
          integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
          crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
            integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
            crossorigin="anonymous" defer></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
            integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
            crossorigin="anonymous" defer></script>
    <script src="/js/highlight.pack.min.js" defer></script>
    <script src="/js/darth10.github.io.min.js" defer></script>
    <script src="https://kit.fontawesome.com/50b9794b1c.js"
            crossorigin="anonymous" samesite="Secure" defer></script>
    
</head>
<body>
    <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
        <a class="navbar-brand" href="/">darth10.github.io</a>
        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse"
                data-target="#navbar-main" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div id="navbar-main" class="navbar-collapse collapse">
            <ul class="nav navbar-nav justify-content-end">
                <li class="nav-item "><a class="nav-link" href="/">Home</a></li>
                <li class="nav-item "><a class="nav-link" href="/archives/">Archives</a></li>
                
                <li class="nav-item ">
                    <a class="nav-link" href="/pages/about/">About</a>
                </li>
                
                <li class="nav-item"><a class="nav-link" href="/feed.xml">RSS</a></li>
            </ul>
        </div>
    </nav>


    <div class="container">
        <div class="row">
            <div id="content" class="container-fluid">
<div id="post">

    <div class="post-header">
    <h2>Can partial classes solve the expression problem?</h2>
    <div class="post-meta">
        <div class="date">4 March 2020</div>
    </div>
</div>
<div>
    
    <p>Programmers are always defining types and operations to use these types. It's the essence of developing features in working software. The <i>expression problem</i><sup><a href="#ref-1">[1]</a></sup> asks how easy it is to define types and operations in a given programming language or paradigm, and is stated as follows:</p><blockquote><p> <i>"The goal is to define a datatype by cases, where one can add new cases to</i> <i>the datatype and new functions over the datatype, without recompiling existing</i> <i>code, and while retaining static type safety (e.g., no casts)."</i> </p></blockquote><p></p><p>To elaborate, a set of definitions or abstractions can claim to have solved the expression problem if it is possible to:</p><ol><li>Add new <i>data types</i>, or simply <i>types</i>.</li><li>Add new <i>functions</i>, or <i>operations</i> over the defined types.</li><li>Not recompile existing code while adding new types or operations.</li><li>Retain static type safety.</li></ol><p>Programming languages generally provide several features to tackle the expression problem. These features have their trade-offs, just like the languages that provide them. Clojure, for example, has support for <a href="https://clojure.org/reference/multimethods">multimethods</a> that allow us to define any number of polymorphic functions that operate over a set of data types. Of course, Clojure is dynamically typed, which doesn't meet the requirement of static type safety by definition. On the other hand, most statically typed languages support interfaces that can be implemented by multiple data types. However, such implementations often make use of type casting, which is rather dubious for static type safety.</p><p>As an example, let's say we're implementing  <i>expression trees</i><sup><a href="#ref-2">[2]</a></sup>, which are used to represent arithmetic expressions. A numeric literal can be represented by a <code>Const</code> type and an <code>Add</code> type can represent an addition of two expressions. Let's define an operation to evaluate the result of an expression. We'll call this operation <code>Eval</code>. Now, without recompiling existing code or compromising type safety, is it possible to make the following changes?</p><ol><li>Add a new operation <code>View</code> to print an expression.</li><li>Add a new type <code>Mult</code> to represent multiplication of two expressions.</li></ol><p>That seems simple enough. Is it possible to implement a solution in C#? If we define the types <code>Const</code> and <code>Add</code> to implement an interface <code>IExpr</code>. This interface would define <code>Eval</code> as a method. This would make it easy to add a new type <code>Mult</code>, but adding a new method <code>View</code> in the interface <code>IExpr</code> would require changes to all existing types. So, it's easy to add new types with this approach, but it's not possible to add new operations without changing and recompiling existing definitions.</p><p>Another approach would be to use multiple interfaces for different operations  like <code>Eval</code> and <code>View</code>. These interfaces could then be  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation">implemented explicitly</a> in types like <code>Const</code>, <code>Add</code> and <code>Mult</code>. However, this implementation would require type  casting, which doesn't really maintain static type safety.</p><p>Let's try using <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods">partial classes</a> to implement a solution. Essentially, partial classes allow the definition of a single class to be spread over multiple definitions or files through use of the <code>partial</code> qualifier. Interfaces can also be defined using the <code>partial</code> qualifier.</p><p>Firstly, let's define the <code>IExpr</code> interface. This interface will declare a single method <code>Eval</code>.</p><pre><code class="csharp">public partial interface IExpr
{
    double Eval();
}
</code></pre><p>The types <code>Const</code> and <code>Add</code> can now be defined as partial classes that implement this interface.</p><pre><code class="csharp">public partial class Const : IExpr
{
    public double Value { get; }

    public Const(double value) =&gt;
        Value = value;
}

public partial class Add : IExpr
{
    public IExpr Left { get; }
    public IExpr Right { get; }

    public Add(IExpr left, IExpr right) =&gt;
        (Left, Right) = (left, right);
}
</code></pre><p>A <code>Const</code> expression is defined to wrap a single <code>double</code> value, and an <code>Add</code> expression contains two properties <code>Left</code> and <code>Right</code> that are expressions themselves. Of course, this code won't compile as the <code>Eval</code> method isn't implemented by the <code>Const</code> and <code>Add</code> types. Let's go ahead and implement this method, but in separate definitions using <code>partial</code> as follows:</p><pre><code class="csharp">public partial class Const
{
    public double Eval() =&gt; Value;
}

public partial class Add
{
    public double Eval() =&gt;
        Left.Eval() + Right.Eval();
}
</code></pre><p>So, the <code>Eval</code> operation is now implemented by the <code>Const</code> and <code>Add</code> types. Let's declare the <code>View</code> method in the <code>IExpr</code> interface by using a separate <code>partial</code> definition.</p><pre><code class="csharp">public partial interface IExpr
{
    string View();
}
</code></pre><p>Now, the compiler complains that the <code>Const</code> and <code>Add</code> types don't implement the <code>View</code> method. Similar to how the <code>Eval</code> method was implemented, the <code>View</code> method can be implemented in separate <code>partial</code> definitions as follows:</p><pre><code class="csharp">public partial class Const
{
    public string View() =&gt;
        Value.ToString();
}

public partial class Add
{
    public string View() =&gt;
        $"({Left.View()} + {Right.View()})";
}
</code></pre><p>Great! We can add an operation without modifying the existing definitions of <code>Const</code> and <code>Add</code>. If we had to implement a new type <code>Mult</code> to represent arithmetic multiplication of two expressions, we can easily define <code>Mult</code> as a partial class that implements the <code>IExpr</code> interface as follows:</p><pre><code class="csharp">public partial class Mult : IExpr
{
    public IExpr Left { get; }
    public IExpr Right { get; }

    public Mult(IExpr left, IExpr right) =&gt;
        (Left, Right) = (left, right);
}

public partial class Mult
{
    public double Eval() =&gt;
        Left.Eval() * Right.Eval();
}

public partial class Mult
{
    public string View() =&gt;
        $"({Left.View()} * {Right.View()})";
}
</code></pre><p>That was real easy! It was almost as easy as defining the <code>Const</code> and <code>Add</code> types along with their implementations of <code>Eval</code> and <code>View</code>. In fact, it's easy to define types and independent operations as partial classes because they're actually <i>open classes</i><sup><a href="#ref-3">[3]</a></sup>.</p><p>It's worth noting that all definitions of a partial class are compiled into a single class in a given assembly. So, it can be argued that adding new definitions to an existing partial class causes recompilation of the entire class. While this is definitely true, existing methods in the class will produce the same compilation output as long as they haven't been modified. Partial classes thus have the effect of not recompiling existing code.</p><p>To truly avoid recompilation of a partial class after adding a new definition, the new definition would have to be in a different assembly. Unfortunately, this is not really possible as one of the limitations of parital classes is that they cannot span multiple assemblies or namespaces.</p><p>Despite these limitations, partial classes and interfaces can be used this way to implement an adequate solution to the expression problem in C#.</p><p>The code in this post can be found <a href="https://github.com/darth10/expression-problem/tree/master/csharp/PartialClasses">here</a> along with  <a href="https://github.com/darth10/expression-problem/tree/master/csharp/PartialClasses.Tests">relevant tests</a>.</p><h4 id="references">References</h4><ol><li><a name="ref-1" rel="nofollow" target="_blank" href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">   The Expression Problem</a> -  Wadler, Philip (1998).</li><li><a name="ref-2" rel="nofollow" target="_blank" href="https://web.archive.org/web/20170119094603/http://www.brpreiss.com/books/opus5/html/page264.html">   Expression Trees</a> -  Preiss, Bruno R. (1998).</li><li><a name="ref-3" rel="nofollow" target="_blank" href="https://people.csail.mit.edu/dnj/teaching/6898/papers/multijava.pdf">   MultiJava: Modular Open Classes and Symmetric Multiple Dispatch for Java   </a> - Clifton, Curtis; Leavens, Gary T.; Chambers, Craig; Millstein, Todd   (2000).</li></ol>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags/Solving the expression problem/">Solving the expression problem</a>
    
</div>


    <div id="prev-next">
        
        <a href="/posts/can-extension-methods-solve-the-expression-problem/">&laquo; Can extension methods solve the expression problem?</a>
        
        
        <a class="right" href="/posts/linq-is-not-quick/">LINQ Is Not Quick &raquo;</a>
        
    </div>

    
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_config = function () {
            this.page.url = "https://darth10.github.io/posts/can-partial-classes-solve-the-expression-problem/";
            this.page.identifier = "Can partial classes solve the expression problem?";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.defer = true;
            dsq.src = '//darth10.disqus.com/embed.js';
            dsq.setAttribute('samesite', 'Secure');
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    

</div>
</div>
        </div><!--/.row -->
        <footer>Copyright &copy; 2021 Akhil Wali
            (<a href="https://github.com/darth10/darth10.github.io/blob/master/LICENSE.md"
                target="_blank" rel="noreferrer">GPLv2 License</a>)
            <p style="text-align: center;">Powered by
                <a href="http://cryogenweb.org" target="_blank" rel="noreferrer">Cryogen</a> and
                <a href="https://pages.github.com/" target="_blank" rel="noreferrer">GitHub Pages</a>
            </p>
        </footer>
    </div><!--/.container -->
</body>
</html>
