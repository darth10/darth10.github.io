<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://darth10.github.io/" rel="self" type="application/rss+xml"/><title>darth10.github.io</title><link>https://darth10.github.io/</link><description>darth10's blog</description><lastBuildDate>Sat, 11 Sep 2021 20:52:40 +1200</lastBuildDate><generator>clj-rss</generator><item><guid>https://darth10.github.io/posts/can-extension-methods-solve-the-expression-problem/</guid><link>https://darth10.github.io/posts/can-extension-methods-solve-the-expression-problem/</link><title>Can extension methods solve the expression problem?</title><description>Let's explore how extension methods in C# can solve the expression problem. For an introduction to the expression problem, take a look at the previous post in this series. Extension methods are essentially used to define operations over a given type without modifying the original definition of the type.First, we define IExpr as a marker interface and implement it in the Const and Add types. The implementation of Const and Add here is identical to that in the previous post.</description><pubDate>Sat, 14 Mar 2020 00:00:00 +1300</pubDate></item><item><guid>https://darth10.github.io/posts/can-partial-classes-solve-the-expression-problem/</guid><link>https://darth10.github.io/posts/can-partial-classes-solve-the-expression-problem/</link><title>Can partial classes solve the expression problem?</title><description>Programmers are always defining types and operations to use these types. It's the essence of developing features in working software. The expression problem[1] asks how easy it is to define types and operations in a given programming language or paradigm, and is stated as follows: "The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts)." </description><pubDate>Wed, 04 Mar 2020 00:00:00 +1300</pubDate></item><item><guid>https://darth10.github.io/posts/linq-is-not-quick/</guid><link>https://darth10.github.io/posts/linq-is-not-quick/</link><title>LINQ Is Not Quick</title><description>Let me just say that I am not particularly a fan of either  microbenchmarks or premature optimization. I also feel that LINQ extensions are a fine addition to the .NET standard library. The LINQ query syntax is also an integral part of the C# and F# languages.That being said, there's an interesting and revealing tale to be told about the performance of LINQ to Objects.</description><pubDate>Fri, 18 Oct 2019 00:00:00 +1300</pubDate></item><item><guid>https://darth10.github.io/posts/lazy-sequences-and-streams/</guid><link>https://darth10.github.io/posts/lazy-sequences-and-streams/</link><title>Lazy sequences and streams</title><description>Functional languages have the notion of lazy sequences, which are an abstraction of infinite sequences that are stored using a small, finite amount of memory. It would be wasteful to realize an entire infinite sequence before even using it. The basic idea is to only call the function that generates the sequence when needed, and cache the results. With lazy sequences, you don't blow the stack and the elements in the sequence are not recalculated everytime.Let's look at how the two most popular and functional JVM languages handle lazy sequences.</description><pubDate>Fri, 25 Jan 2013 00:00:00 +1300</pubDate></item><item><guid>https://darth10.github.io/posts/the-webbrowser-nightmare/</guid><link>https://darth10.github.io/posts/the-webbrowser-nightmare/</link><title>The WebBrowser nightmare</title><description>I recently had to use the WebBrowser .NET component in a project. The control is essentially Internet Explorer embedded in a UserControl component. Although the facilities for JavaScript interoperability and DOM manipualtion are pretty great, the control fails to meet simpler needs.To override keyboard input handing in the control, we need to set the WebBrowserShortcutsEnabled property to false and handle the PreviewKeyDown event.</description><pubDate>Sun, 23 Sep 2012 00:00:00 +1200</pubDate></item><item><guid>https://darth10.github.io/posts/abstract-and-parameterized-types/</guid><link>https://darth10.github.io/posts/abstract-and-parameterized-types/</link><title>Abstract and parameterized types</title><description>Scala supports both abstract and parameterized types, which are essentially revamped generics (in Java) or templates (in C++).First off, methods can be parameterized, in order to abstract a generic type which can be used by it. The apply method in companion objects is the best place to start. Here's an example from the implementation of the List class in the Scala library.</description><pubDate>Thu, 16 Aug 2012 00:00:00 +1200</pubDate></item><item><guid>https://darth10.github.io/posts/byte-selection-sort/</guid><link>https://darth10.github.io/posts/byte-selection-sort/</link><title>61 byte selection sort</title><description>Here's the absolutely smallest array sorting function in C. It's written by M. Doughlas McIlroy of Darthmouth College, NH USA. It only 67 bytes long (ignoring new-line characters), which is ridiculously impressive. In the function s shown below, a is the starting address of the array, and b is the address of the last element plus one.This can be made even smaller using recursion and by inferring the type specifiers of global object declarations, which is a GCC hack. In the following function, n is the number of elements in the array a.</description><pubDate>Wed, 13 Jan 2010 00:00:00 +1300</pubDate></item><item><guid>https://darth10.github.io/posts/network-packets-with-py/</guid><link>https://darth10.github.io/posts/network-packets-with-py/</link><title>Network packets with Python</title><description>Next week, I'll have to start a project on implementing RIP (Routing Information Protocol) using UDP sockets in C. I needed a quick way to get the byte structure of RIP packets, and decided to use scapy. It's quite a handy tool and has a simple interface, which is nothing more than an extended Python shell. Auto-completion is supported out-of-the-box, which is good news for all the command-line enthusiasts out there. Here's how we dump an RIP packet straight to a PDF file.This generates a self-explanatory packet dump. You could also use a different reader; just change the conf.prog.pdfreader object.</description><pubDate>Tue, 19 May 2009 00:00:00 +1200</pubDate></item><item><guid>https://darth10.github.io/posts/name-and-http-servers/</guid><link>https://darth10.github.io/posts/name-and-http-servers/</link><title>__name__ and HTTP servers</title><description>The __name__ built-in Python variable which describes exactly that - it's the name of the module during runtime. Python modules use this variable to perform a particular action when the module is run, and probably do something else when imported by another module. It also facilitates module testing if you think about it.Ideally, every Python module that is intended to be reused must have something like this in it, preferably at the end.</description><pubDate>Wed, 13 May 2009 00:00:00 +1200</pubDate></item></channel></rss>